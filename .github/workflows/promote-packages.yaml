# This automation promotes 3p packages to development when a maintainer adds the promote-packages label

name: Promote 3P Packages

run-name: >-
  ${{
    github.event_name == 'pull_request'
    && format('Promotion - {0} (PR #{1})', github.event.pull_request.title, github.event.pull_request.number)
    || 'Promote 3P Packages'
  }}

on:
  # Allows you to run this workflow manually from the Actions screen
  workflow_dispatch:
    inputs:
      PR-num:
        type: string
        required: false
        description: PR number to pull from. Leave blank to pull from last successful run
      Run-id-num:
        type: string
        required: false
        description: Run id number (located in the build url) to pull from. Leave blank to pull from last successful run

  # Triggered when a label is added to a PR
  pull_request:
    types: [labeled]
    branches:
      - main
      - development

jobs:
  check-authorization:
    name: Check promotion authorization
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      should-promote: ${{ steps.check.outputs.should-promote }}
      pr-number: ${{ github.event.pull_request.number }}
    steps:
      - name: Check if correct label was added
        id: label-check
        run: |
          LABEL="${{ github.event.label.name }}"
          if [[ "$LABEL" != "promote-packages" ]]; then
            echo "Label '$LABEL' is not 'promote-packages', skipping promotion"
            echo "is-promote-label=false" >> $GITHUB_OUTPUT
          else
            echo "Promote label detected"
            echo "is-promote-label=true" >> $GITHUB_OUTPUT
          fi

      - name: Check if user is a maintainer
        if: steps.label-check.outputs.is-promote-label == 'true'
        id: maintainer-check
        env:
          GH_TOKEN: ${{ secrets.GHA_TOKEN }}
        run: |
          ACTOR="${{ github.actor }}"
          echo "Checking if $ACTOR is a member of o3de/maintainers..."

          # Check team membership
          if gh api "/orgs/o3de/teams/maintainers/memberships/$ACTOR" --silent 2>/dev/null; then
            echo "User $ACTOR is authorized (member of o3de/maintainers)"
            echo "is-maintainer=true" >> $GITHUB_OUTPUT
          else
            echo "User $ACTOR is NOT a member of o3de/maintainers"
            echo "is-maintainer=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check if build workflow succeeded
        if: steps.label-check.outputs.is-promote-label == 'true' && steps.maintainer-check.outputs.is-maintainer == 'true'
        id: build-check
        env:
          GH_TOKEN: ${{ secrets.GHA_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "Checking build status for PR #$PR_NUMBER (commit $HEAD_SHA)..."

          # Get workflow runs for the build workflow on this PR
          BUILD_STATUS=$(gh api "/repos/${{ github.repository }}/actions/workflows/build-package.yaml/runs?head_sha=$HEAD_SHA" \
            --jq '.workflow_runs[0].conclusion // "not_found"')

          if [[ "$BUILD_STATUS" == "success" ]]; then
            echo "Build workflow succeeded"
            echo "build-passed=true" >> $GITHUB_OUTPUT
          else
            echo "Build workflow status: $BUILD_STATUS"
            echo "Build must succeed before promotion can proceed"
            echo "build-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Set promotion output
        id: check
        if: always()
        run: |
          if [[ "${{ steps.label-check.outputs.is-promote-label }}" == "true" && \
                "${{ steps.maintainer-check.outputs.is-maintainer }}" == "true" && \
                "${{ steps.build-check.outputs.build-passed }}" == "true" ]]; then
            echo "should-promote=true" >> $GITHUB_OUTPUT
          else
            echo "should-promote=false" >> $GITHUB_OUTPUT
          fi

  deploy-dev:
    name: Deploying to dev S3 bucket
    needs: [check-authorization]
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' ||
       (github.event_name == 'pull_request' && needs.check-authorization.outputs.should-promote == 'true'))
    runs-on: ubuntu-latest
    environment: development
    env:
      PACKAGE_PATH: packages/
    outputs:
      filelist: "${{ steps.dev-upload.outputs.filelist }}"
      package-name: "${{ steps.extract-package.outputs.package-name }}"
    steps:
      - name: Download packages
        uses: dawidd6/action-download-artifact@v2.28.0
        with:
          workflow: build-package.yaml
          pr: ${{ github.event_name == 'pull_request' && github.event.pull_request.number || inputs.PR-num }}
          run_id: ${{ inputs.Run-id-num }}
          check_artifacts: true
          path: ${{ env.PACKAGE_PATH }}

      - name: Extract package name from artifacts
        id: extract-package
        run: |
          # Get the first package name from downloaded artifacts
          PACKAGE_NAME=$(ls -1 ${{ env.PACKAGE_PATH }} | head -1)
          echo "package-name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "Found package: $PACKAGE_NAME"

      - name: Check if package already exists in prod
        env:
          PROD_CDN: ${{ vars.PROD_CDN }}
        run: |
          find ${{ env.PACKAGE_PATH }} -type f | while read file; do
            filename=$(basename "$file")
            url="${{ env.PROD_CDN }}/${filename}"
            if curl --head --silent --fail ${url} > /dev/null 2>&1; then
              echo ${filename} already exists in prod. Check the rev in the json file to ensure it is incremented
              exit 1
            else
              echo ${filename} does not exist in CDN, continuing...
            fi
           done

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
           aws-access-key-id    :  ${{ secrets.AWS_CREDS_ACCESS_KEY }}
           aws-secret-access-key:  ${{ secrets.AWS_CREDS_SECRET_KEY }}
           aws-region           :  ${{ secrets.AWS_CREDS_REGION_NAME }}

      - name: Copy to S3
        id: dev-upload
        shell: bash
        run: |
          find ${{ env.PACKAGE_PATH }} -type f | while read file; do
            filename=$(basename "$file")
            aws s3 cp "$file" "s3://${{ secrets.AWS_PACKAGE_DEV_S3_BUCKET }}/$filename" --acl bucket-owner-full-control
            FILELIST="$FILELIST$filename,"
            echo "filelist=$( echo "$FILELIST" )" >> $GITHUB_OUTPUT
          done

  create-o3de-3p-pr:
    name: Create PR in O3DE to update version
    needs: [check-authorization, deploy-dev]
    if: |
      always() &&
      needs.deploy-dev.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      o3de-pr-url: ${{ steps.create-pr.outputs.pull-request-url }}
      o3de-pr-number: ${{ steps.create-pr.outputs.pull-request-number }}
    env:
      O3DE_REPO_PATH: o3de
      DEV_CDN: ${{ vars.DEV_CDN }}
      UPLOADED_FILES: "${{ needs.deploy-dev.outputs.filelist }}"
      SOURCE_PR_NUMBER: ${{ github.event_name == 'pull_request' && github.event.pull_request.number || inputs.PR-num }}
      SOURCE_PR_URL: ${{ github.event_name == 'pull_request' && github.event.pull_request.html_url || format('{0}/{1}/pull/{2}', github.server_url, github.repository, inputs.PR-num) }}

    steps:
    - name: Checkout o3de repository
      uses: actions/checkout@v4
      with:
        repository: o3de/o3de
        token: ${{ secrets.GHA_TOKEN }}
        path: o3de

    - name: Copy dev package from S3
      run: |
        IFS=',' read -ra FILES <<< "$UPLOADED_FILES"
        for filename in "${FILES[@]}"; do
            if [[ $filename == *.tar.xz.SHA256SUMS ]]; then
              wget "${{ env.DEV_CDN }}/$filename"
            fi
        done

    - name: Update BuiltInPackages with new SHA256 and version
      shell: bash
      run: |
        IFS=',' read -ra FILENAMES <<<"$UPLOADED_FILES"
        for filename in "${FILENAMES[@]}"; do
          if [[ $filename == *.tar.xz.SHA256SUMS ]]; then
            content=$(cat "$filename")
            file=$(echo "$content" | awk -F'*' '{print $2}' | sed 's/.tar.xz//g') # *<package_name>-<version>-o3de-<rev>-<platform>.tar.xz
            hash=$(echo "$content" | awk '{print $1}')
            PACKAGE_NAME=$(echo "$file" | cut -d'-' -f1-2)  # Extract package name without platform
            PARTIAL_PACKAGE_NAME=$(echo "$PACKAGE_NAME" | cut -d'-' -f1)  # Extract the first part of the package name for matching
            PLATFORM=$(echo "$file" | rev | cut -d'-' -f1 | rev)

            # Determine x86 or aarch64 cmake file name based on file suffix
            if [[ $file == *linux-aarch64 ]]; then
                CMAKE_FILE=BuiltInPackages_linux_aarch64.cmake
                PLATFORM=linux
            elif [[ $file == *linux ]]; then
                CMAKE_FILE=BuiltInPackages_linux_x86_64.cmake
            elif [[ $file == *mac-arm64 ]]; then
                CMAKE_FILE=BuiltInPackages_mac_arm64.cmake
                PLATFORM=mac
            elif [[ $file == *mac ]]; then
                CMAKE_FILE=BuiltInPackages_mac.cmake
                PLATFORM=mac
            else
                CMAKE_FILE=BuiltInPackages_$PLATFORM.cmake
            fi

            FILE_PATH="${{ env.O3DE_REPO_PATH }}/cmake/3rdParty/Platform/${PLATFORM^}/$CMAKE_FILE"

            if [[ $PLATFORM == ios ]]; then
                FILE_PATH="${{ env.O3DE_REPO_PATH }}/cmake/3rdParty/Platform/iOS/$CMAKE_FILE"
            fi

            # Sample the first line after the comment "# platform-specific" to detect width
            sample_line=$(awk '/# platform-specific/{getline; print}' "$FILE_PATH")
            # Detect the width of the line until TARGETS
            width_before_targets=$(echo "$sample_line" | awk -F'TARGETS' '{print length($1 FS) - length("ly_associate_package(PACKAGE_NAME ") - length(" TARGETS")}')
            # Construct the new line using printf with the detected width
            new_line=$(printf "ly_associate_package(PACKAGE_NAME %-*s TARGETS %-27s PACKAGE_HASH %s" $width_before_targets "$file" "$PARTIAL_PACKAGE_NAME" "$hash")

            test_path=$(grep -q "$PARTIAL_PACKAGE_NAME" "$FILE_PATH" && echo 0 || echo 1)
            if [ $test_path -eq 0 ]; then
                sed -i "s|ly_associate_package(PACKAGE_NAME $PARTIAL_PACKAGE_NAME-[^ ]* .*PACKAGE_HASH [a-f0-9]\{64\}|$new_line|g" "$FILE_PATH"
            else
                echo "$new_line" >> "$FILE_PATH"
            fi
          fi
        done

        echo "package_name=$PACKAGE_NAME" >> $GITHUB_ENV

    - name: Commit and create PR
      id: create-pr
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GHA_TOKEN }}
        path: ${{ env.O3DE_REPO_PATH }}
        base: development
        branch: "update-3p-${{ env.package_name }}-cmake-file"
        commit-message: "Update 3P version and SHA256 hash for ${{ env.package_name }}"
        title: "Update 3P version and SHA256 hash for ${{ env.package_name }}"
        body: |
          ## Automated 3P Package Update

          **Package**: ${{ env.package_name }}
          **Source PR**: ${{ env.SOURCE_PR_URL }}
          **Build Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ### Changes
          Updates the 3P package version and SHA256 hash in the BuiltInPackages cmake files.

          ### Production Deployment
          Production deployment will occur automatically after:
          1. This PR's checks pass
          2. The source 3P PR is merged

          ---
          _This PR was automatically generated by the 3p-package-source promotion workflow._
        draft: true
        signoff: true
        delete-branch: true

    - name: Comment on source PR with O3DE PR link
      if: steps.create-pr.outputs.pull-request-url && github.event_name == 'pull_request'
      env:
        GH_TOKEN: ${{ secrets.GHA_TOKEN }}
      run: |
        gh pr comment ${{ github.event.pull_request.number }} \
          --repo ${{ github.repository }} \
          --body "O3DE PR created: ${{ steps.create-pr.outputs.pull-request-url }}

        **Next steps:**
        1. Wait for O3DE PR checks to pass
        2. Merge this PR to trigger production deployment
        3. Production deployment will copy packages from dev to prod S3"
